[{"title":"你好 世界！","url":"/2022/03/08/hello-world/","content":"真难搭\n快速开始新建文章$ hexo new &quot;文章名&quot;\n\n\n\n创建分页文章$ hexo new page &quot;分页名&quot;\n\n\n\n清除缓存$ hexo clear\n\n\n\n开启本地服务器$ hexo s\n\n\n\n静态文件保存本地$ hexo g\n\n\n\n上传GitHub$ hexo d\n\n","categories":["闲话"]},{"title":"闲话","url":"/2022/03/08/%E9%97%B2%E8%AF%9D/","content":"也不知道说什么，随便写写，不定期更新\n","categories":["闲话"],"tags":["作者的话"]},{"title":"Cookie转码解码","url":"/2022/03/08/Cookie%E8%BD%AC%E7%A0%81%E8%A7%A3%E7%A0%81/","content":"先搞清楚为什么Cookie对象不能存储中文\n\n根据Tomcat版本区分\n\n\n在Tomcat 8 之前,cookie中不能直接存储中文数据。需要将中文数据转码,否则会直接报错\n在Tomcat 8之后,cookie支持中文数据,但是,特殊字符还是不支持（比如空格)\n\n如何转码与解码\n\n代码片段\n\n//创建Cookie对象//可以看到这是正常创建存值，但是如果存入了中文，在编译时低版本Tomcat会报500错误//Cookie cookie = new Cookie(&quot;名称&quot;,&quot;值&quot;)//转码存储//通过URLEncoder对象的encode()方法，可将字符串转码成指定的编码格式，这里统一使用UTF-8//用法：URLEncoder.encode(&quot;字符串&quot;,&quot;需要转码的编码格式&quot;)Cookie cookie = new Cookie(&quot;名称&quot;,URLEncoder.encode(&quot;值&quot;,&quot;UTF-8&quot;));//存入到浏览器缓存response.addCookie(cookie);//解码Cookie//getCookie()返回的是一个Cookie的数组，先拿Cookie对象数组接收Cookie[] ck = request.getCookies();//防止Cookie传入空值if(cookie!=null)&#123;    //在网页输出Cookie的name和值 先正常编写    //这个时候可以输出出来，不会报错，但是如果存入的是中文或者其他特殊符号    //输出出来的结果会是一串乱码，这时候需要解码    //Systemctl.out.print(&quot;名称：&quot; + ck.getName());    //Systemctl.out.print(&quot;值：&quot; + ck.getValue());      //解码：    //通过URLDecoder对象的decode()方法进行解码    //用法：URLDecoder.decode(&quot;字符串&quot;,&quot;需要解码的编码格式&quot;)    //上面用的是UTF-8格式存储，所以这里对应的将UTF-8进行解码    Systemctl.out.print(&quot;名称：&quot;+URLDecoder.decode(ck.getName(),&quot;UTF-8&quot;));    Systemctl.out.print(&quot;值：&quot;+URLDecoder.decode(ck.getValue(),&quot;UTF-8&quot;));&#125;\n\n\n\n----------END----------\n\n","categories":["编程"],"tags":["javaWeb","后端","jsp","java"]},{"title":"Java i/o流","url":"/2022/03/08/io%E6%B5%81/","content":"1、使用文件类 ： File类如何获取文件信息\n\n\n方法\n说明\n返回值类型\n\n\n\ngetName()\n获取文件名称\nString\n\n\ngetParent()\n获取文件的父路径字符串\nString\n\n\ngetPath()\n获取文件的相对路径字符串\nString\n\n\ngetAbsolutePath()\n获取文件的绝对路径字符串\nString\n\n\nexists()\n判断文件或者文件夹是否存在\nboolean\n\n\nisFile()\n判断是不是文件类型\nboolean\n\n\nisDirectory()\n判断是不是文件夹类型\nboolean\n\n\ndelete()\n删除文件或文件夹，如果删除成功返回结果为true否则false,删除时文件夹内必须为空\nboolean\n\n\nmkdir()\n创建文件夹，创建成功返回true\nboolean\n\n\nsetReadOnly()\n设置文件或文件夹的只读属性\nboolean\n\n\nlength()\n获取文件的长度\nlong\n\n\nlastModified()\n获取文件的最后修改时间\nlong\n\n\nlist()\n获取文件夹中的文件和子文件夹的名称，并存放到字符串数组中\nString[]\n\n\n动手试一试package com.rlone.javaio;import java.io.File;import java.util.Date;/** *  * @author Rlone *  */public class FileInfo &#123;\tpublic static void main(String[] args) &#123;\t\t//创建File对象并且获取文件\t\tString filePath = &quot;src/com/rlone/io/FileInfo.java&quot;;\t\t// 根据指定路径创建文件对象\t\tFile file = new File(filePath);\t\tSystem.out.println(&quot;文件名称:&quot; + file.getName());\t\tSystem.out.println(&quot;文件是否存在：&quot; + file.exists());\t\tSystem.out.println(&quot;文件的相对路径：&quot; + file.getPath());\t\tSystem.out.println(&quot;文件的绝对路径：&quot; + file.getAbsolutePath());\t\tSystem.out.println(&quot;是否为可执行文件：&quot; + file.canExecute());\t\tSystem.out.println(&quot;文件可以读取：&quot; + file.canRead());\t\tSystem.out.println(&quot;文件可以写入：&quot; + file.canWrite());\t\tSystem.out.println(&quot;文件上级路径：&quot; + file.getParent());\t\tSystem.out.println(&quot;文件大小：&quot; + file.length() + &quot;B&quot;);\t\tSystem.out.println(&quot;文件最后修改时间：&quot; + new Date(file.lastModified()));\t\tSystem.out.println(&quot;是否文件类型：&quot; + file.isFile());\t\tSystem.out.println(&quot;是否为文件夹：&quot; + file.isDirectory());\t&#125;&#125;\n\n查看运行结果文件名称:FileInfo.java文件是否存在：true文件的相对路径：src\\com\\zch\\io\\FileInfo.java文件的绝对路径：D:\\Java\\IO\\src\\com\\rlone\\io\\FileInfo.java是否为可执行文件：true文件可以读取：true文件可以写入：true文件上级路径：src\\com\\zch\\io文件大小：115B文件最后修改时间：Sat Sep 09 21:30:10 CST 2017是否文件类型：true是否为文件夹：false\n\n\n\n2.字节输入流抽象类InputStream字节流用于处理二进制数据的读取和写入，它以字节为单位\n\nInputStream 类是字节输入流的抽象类，定义了操作输入流的各种方法，这些方法如表：\n\n\n方法\n说明\n返回值\n\n\n\navailable()\n返回当前输入流的数据读取方法可以读取的有效字节数量\nint\n\n\nread()\n从当前数据流中读取一个字节。若已达到流结尾，则返回-1\nint\n\n\nread(byte[ ] bytes)\n从当前输入流读取一定的byte数据，并存取在数组中，然后返回读取的byte数据的数量，若已到达流结尾，则返回-1。\nint\n\n\nreset()\n将当前的输入流重新定位到最后一次调用mark()方法时的位置\nvoid\n\n\nmark(int readlimit)\n在当前输入流中做标记位置，当调用reset()方法时将返回到该位置，从标记位置开始，到再读入readlimit个字符为止，这个标记都维持有效。\nvoid\n\n\nmarkSupported()\n测试当前输入流是否支持mark()和reset()方法，只要其中一个不支持，则返回false\nboolean\n\n\nskip(long n)\n跳过和丢弃当前输入的n个字节数据\nlong\n\n\nclose()\n关闭当前输入流，并释放任何与之相关联的系统资源\nvoid\n\n\nInputStream 类是抽象类，不能通过new关键字来创建该实例对象，需要其子类创建该实例对象。下面通过实例如何使用InputStream从控制台获取用户输入的数据信息。\npackage com.rlone.io;import java.io.IOException;import java.io.InputStream;/** * 创建InputStream实例inp，并将其赋值为System类的in属性，定义为控制台输入流，从inp输入流中获取字节信息， * 用这些字节信息创建字符串，并将其在控制台上输出。 * @author Rlone * */public class InputMessage &#123;\tpublic static void main(String[] args) &#123;\t\tInputStream is = System.in;\t\t\t\tbyte[] bytes = new byte[1024];\t\t\t\ttry &#123;\t\t\twhile(is.read() != -1)&#123;\t\t\t\t//根据输入的信息创建字符串\t\t\t\tString str = new String(bytes).trim();\t\t\t&#125;\t\t\tis.close();\t\t//关闭输入流\t\t&#125; catch (IOException e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t\t\t&#125;&#125;\n\n3.字节输出流抽象类OutputStream类OutputStream定义了输出流的各种方法，如下表：\n\n\n方法\n说明\n返回值\n\n\n\nwrite(byte[ ] b)\n将byte[ ] 数组中的数据写入当前输出流\nvoid\n\n\nwrite(byte[] b ,int off, int len)\n将byte[ ]数组下标off开始的len长度的数据写入当前输出流void\nvoid\n\n\nwrite（int i)\n写入一个byte数据到当前输出流\nvoid\n\n\nflush()\n刷新当前输出流，并强制写入所有缓冲的字节数据\nvoid\n\n\nclose()\n关闭当前输出流\nvoid\n\n\n OutputStream 类是抽象类，不能通过new关键字来创建该实例对象，需要其子类创建该实例对象。\npackage com.rlone.io;import java.io.IOException;import java.io.OutputStream;/** * 创建OutputStream实例out,并将其赋值为System.out标准输出流。通过write()方法向流写入数据。 * @author Rlone * */public class OutputData &#123;\tpublic static void main(String[] args) &#123;\tOutputStream output = System.out;\t\t\t//实例化OutputStream对象\t\tbyte[] bytes = &quot;使用OutputStream输出流在控制台输出字符串\\n&quot;.getBytes();\t\t//创建bytes数组\t\ttry &#123;\t\toutput.write(bytes);\t\t\t\tbytes = &quot;输出内容：\\n&quot;.getBytes();\t\toutput.write(bytes);        //向流中写入数据\t\t\t\tbytes = &quot;Java数据交互管道 ---- IO流 \\n&quot;.getBytes();\t\toutput.write(bytes);\t\t\t\toutput.close();\t\t\t&#125; catch (IOException e) &#123;\t\te.printStackTrace();\t&#125;\t&#125;&#125;\n\n输出结果如下\n使用OutputStream输出流在控制台输出字符串输出内容：   Java数据交互管道——IO流 \n\n4、文件字节输入流类 ： FileInputStream类文件字节输入流可以从指定路径的文件中读取字节数据。文件字节输入流类继承InputStream类，并实现了读取输入流的各种方法,\n创建文件字节输入流创建的构造方法语法如下：\n以File对象为参数创建FileInputStream实例\nnew FileInputStream（File file）\n\n以文件对象的绝对路径为参数创建FIleInputStream实例\nnew FileInputStream（String filepath）\n\n5、文件字节输出流类：FileOutputStream文件字节输出流关联指定文件路径的文件，数据通过文件字节输出流以字节为单位输出并保存到文件中。文件字节输出流继承自OutputStream类，并实现OutputStream类的各种方法。\n文件字节输出流的构造方法语法如下：\n以File对象为参数创建FileOutputStream实例\nnew FileOutputStream（File file）\n\n以文件对象的绝对路径为参数创建FIleOutputStream实例\nnew FileOutputStream（String filepath）\n\n下面通过实例介绍文件的写入和读取：\npackage com.rlone.io;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;/** * 创建OutputStream实例out,并将其赋值为System.out标准输出流，通过write方法向流中写入数据 *  * @author Rlone *  */public class FileCreate &#123;\tpublic static void main(String[] args) &#123;\t\tFile file = new File(&quot;D:/&quot;, &quot;word.txt&quot;);  //创建文件对象\t\ttry &#123;            //如果文件不存在则新建文件\t\t\tif (!file.exists()) &#123;\t\t\t\t\t\t\t\tfile.createNewFile();\t\t\t\t\t\t&#125;\t\t\tFileOutputStream output = new FileOutputStream(file);\t\t\tbyte[] bytes = &quot;Java数据交流管道——IO流&quot;.getBytes();            //将数组的信息写入文件中\t\t\toutput.write(bytes);\t\t\t\t\t\t\toutput.close();\t\t&#125; catch (IOException e) &#123;            \t\t\te.printStackTrace();\t\t&#125;\t\ttry &#123;\t\t\tFileInputStream input = new FileInputStream(file);\t\t\tbyte[] bytes2 = new byte[1024];\t\t\tint len = input.read(bytes2);\t\t\tSystem.out.println(&quot;文件中的信息是：&quot; + new String(bytes2, 0, len));\t\t\tinput.close();\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;&#125;\n\n6.字符输入流抽象类：Reader类该类定义了操作字符输入流的方法，如下表：\n\n\n方法\n说明\n返回值\n\n\n\nready()\n判断此数据流是否准备好\nboolean\n\n\nread()\n读入一个字符，若已读到流结尾，则返回值为-1\nint\n\n\nread(char[ ])\n读取一些字符到char[ ]数组内，并返回所读入的字符的数量，若已到达流结尾，则返回-1\nint\n\n\nread(char[ ] chars,int off,int len)\n读取一些字符到char[ ]数组下标从off开始到off+len的位置，并返回所读入的字符的数量，若已到达流结尾，则返回-1；\nint\n\n\nreset()\n将当前输入流重新定位到最后一次mark（）方法时的位置\nvoid\n\n\nmark(int readLimit)\n将当前输入流中做标记，当调用reset方法时将返回到该位置，从标记位置开始，到再读入readLimit个字符为止，这个标记都维持有效\nvoid\n\n\nmarkSupported\n测试当前输入流是否支持mark()方法和reset()方法。只要有一个方法不支持，则返回-1\nboolean\n\n\nskip(long n)\n跳过参数n指定的字符数量，并返回所跳过字符的数量\nlong\n\n\nclose()\n关闭字符输入流，并释放与之关联的所有资源\nvoid\n\n\n7.字符输出流类Writer类 Writer 类主要是用于解决字符输入流的类，其地位与Reader类在输入流的地位和作用是相同的，也是所有字符输出流的流类。\nWriter类的主要方法如下：\n\n\n方法\n说明\n返回值\n\n\n\nwrite(char[ ] cbuf)\n将字符数组的数据写入字符输出流\nvoid\n\n\nwrite(char[ ] cbuf int off ,int len)\n将字符数组从下标off 开始向输入流写入长度为len的数据\nvoid\n\n\nwrite(int c )\n向字符输入流中写入一个字符数据\nvoid\n\n\nwrite(String str )\n向输入流中写入一个字符串数据\nvoid\n\n\nwrite(String str , int off ,int len)\n向输入流中写入一个字符串从off 开始长度为len的数据\nvoid\n\n\nflush()\n刷新当前输出流，并强制写入所有缓冲区的字节数据\nvoid\n\n\nclose()\n向输出流中写入缓冲区的数据，然后关闭当前输出流，释放所有与当前输出流相关联的系统资源\nvoid\n\n\n8.文件字符输入流FileReader文件字符输入流与文件字节输入流的功能相似，但是传送数据的方式不一样，字节流以字节为单位传送数据，可以使文本、视频、音频、图片等。字符流以字符为单位传送数据，只能传送文本类型的数据\n创建字符输入流常用的构造方法：new FileReader（File file;new FileReader（File file;\n\n通过实例介绍FileReader类读取指定磁盘文件的内容。package com.rlone.io;import java.io.File;import java.io.FileReader;public class FileInAndOut &#123;\tpublic static void main(String[] args) &#123;\t\t//定义指定磁盘的文件的File对象\t\tFile file = new File(&quot;D://word.txt&quot;);\t\t\t\tif(! file.exists())&#123;\t\t\tSystem.out.println(&quot;对不起，不包含指定路径的文件&quot;);\t\t&#125;else&#123;\t\t\t//根据指定路径的File对象创建FileReader对象\t\t\ttry &#123;\t\t\t\tFileReader fr = new FileReader(file);\t\t\t\t                //定义char数组\t\t\t\tchar[] data = new char[23];\t\t\t\t\t\t\t\t\t\t\tint length = 0;\t\t\t\t                //循环读取文件中的数据\t\t\t\twhile((length = fr.read(data))&gt;0)&#123;\t\t\t                    //根据读取文件的内容创建String 对象\t\t\t\t\tString str = new String(data,0,length);\t\t\t                    //输出读取内容\t\t\t\t\tSystem.out.println(str);\t\t\t\t\t\t\t\t&#125;                //关闭流\t\t\t\tfr.close();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&#125; catch (Exception e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\t\t\t&#125;\t&#125;&#125;\n\n9.件字符输出流FileWriter文件字符输出流继承自Writer类，提供了向文件输出的各种方法，数据通过文件字符输出流以字符为单位输出并保存到文件中。\npackage com.rlone.io;/** * 通过给定的String类型参数的指定文件名称与路径，创建FileWriter类。 *  * @author zch */import java.io.File;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class FileWriterDemo &#123;\tpublic static void main(String[] args) &#123;        //创建指定文件\t\tFile file = new File(&quot;D://word2.txt&quot;);\t\t\t\t\t\ttry &#123;\t\tif(! file.exists())&#123;            \t//如果指定文件不存在，新建文件\t\t\t\tfile.createNewFile();\t\t\t\t\t\t\t\t\t&#125;\t\t\t\tFileReader fr = new FileReader(&quot;D://word.txt&quot;);\t\t        //创建FileWriter对象\t\tFileWriter fw = new FileWriter(file);\t\t\t\t\t\t\t\tint length = 0;                    //如果没有读到文件末尾\t\twhile((length = fr.read()) != -1)&#123;            //向文件写入数据\t\t\tfw.write(length);\t\t\t\t\t\t\t\t&#125;        //关闭流\t\tfr.close();\t\t\t\t\t\t\t\t\tfw.close();\t\t&#125; catch (IOException e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;&#125;\n\n----------END----------\n","categories":["编程"],"tags":["后端","java","i/o流"]},{"title":"MyBatis","url":"/2022/03/16/MyBatis/","content":"SSM框架：MyBatis（一）MyBatis框架的搭建","tags":["编程","SSM框架","MyBatis"]}]